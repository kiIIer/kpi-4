
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001da  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .debug_aranges 00000040  00000000  00000000  0000022e  2**0
                  CONTENTS, READONLY, DEBUGGING
  2 .debug_pubnames 00000057  00000000  00000000  0000026e  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_info   00000269  00000000  00000000  000002c5  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_abbrev 00000170  00000000  00000000  0000052e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_line   000003d0  00000000  00000000  0000069e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_frame  00000060  00000000  00000000  00000a70  2**2
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_str    0000010d  00000000  00000000  00000ad0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    000000c6  00000000  00000000  00000bdd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
   8:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
   c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  10:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  14:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  18:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  1c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  20:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  24:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  28:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  2c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  30:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  34:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  38:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  3c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  40:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  44:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  48:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  4c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  50:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61
  60:	0e 94 36 00 	call	0x6c	; 0x6c <main>
  64:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <_exit>

00000068 <__bad_interrupt>:
  68:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000006c <main>:
#include <avr/io.h>
#include "util/delay.h"
#include "i2c_eeprom.h"

int main(void)
{
  6c:	80 e4       	ldi	r24, 0x40	; 64
  6e:	9c e9       	ldi	r25, 0x9C	; 156
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  70:	20 e9       	ldi	r18, 0x90	; 144
  72:	31 e0       	ldi	r19, 0x01	; 1
  74:	f9 01       	movw	r30, r18
  76:	31 97       	sbiw	r30, 0x01	; 1
  78:	f1 f7       	brne	.-4      	; 0x76 <main+0xa>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
  7a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
  7c:	d9 f7       	brne	.-10     	; 0x74 <main+0x8>
	_delay_ms(4000); 

    uint8_t byte = 10;  // 0xA0
    uint16_t address = 25; //  0x19

    eeInit();	
  7e:	0e 94 53 00 	call	0xa6	; 0xa6 <eeInit>
    

	// check if byte writed successful
    if(eeWriteByte(address, byte))
  82:	89 e1       	ldi	r24, 0x19	; 25
  84:	90 e0       	ldi	r25, 0x00	; 0
  86:	6a e0       	ldi	r22, 0x0A	; 10
  88:	0e 94 5e 00 	call	0xbc	; 0xbc <eeWriteByte>
  8c:	88 23       	and	r24, r24
  8e:	41 f0       	breq	.+16     	; 0xa0 <main+0x34>
  90:	80 e6       	ldi	r24, 0x60	; 96
  92:	9a ee       	ldi	r25, 0xEA	; 234
  94:	01 97       	sbiw	r24, 0x01	; 1
  96:	f1 f7       	brne	.-4      	; 0x94 <main+0x28>
        byte = 0; 
        
		// waite 15ms before read
        _delay_ms(15); 
        
        byte = eeReadByte(address); 
  98:	89 e1       	ldi	r24, 0x19	; 25
  9a:	90 e0       	ldi	r25, 0x00	; 0
  9c:	0e 94 9a 00 	call	0x134	; 0x134 <eeReadByte>
        
    }
}
  a0:	80 e0       	ldi	r24, 0x00	; 0
  a2:	90 e0       	ldi	r25, 0x00	; 0
  a4:	08 95       	ret

000000a6 <eeInit>:
#include "i2c_eeprom.h"

void eeInit(void)
{
	// setup speed
    TWBR = (F_CPU/slaveF_SCL - 16)/(2 * /* TWI_Prescaler= 4^TWPS */1);
  a6:	8c e0       	ldi	r24, 0x0C	; 12
  a8:	80 b9       	out	0x00, r24	; 0
	/*
	If the TWI is operating in master mode, the TWBR value must be at least 10.
	If the TWBR value is less than 10, the bus master can generate incorrect signals
	on the SDA and SCL lines during the byte transfer.
	*/
    if(TWBR < 10)
  aa:	80 b1       	in	r24, 0x00	; 0
  ac:	8a 30       	cpi	r24, 0x0A	; 10
  ae:	10 f4       	brcc	.+4      	; 0xb4 <eeInit+0xe>
        TWBR = 10;
  b0:	8a e0       	ldi	r24, 0x0A	; 10
  b2:	80 b9       	out	0x00, r24	; 0
    
	//Setting the prescaler in the status register of the Control Unit.
    TWSR &= (~((1<<TWPS1)|(1<<TWPS0)));
  b4:	81 b1       	in	r24, 0x01	; 1
  b6:	8c 7f       	andi	r24, 0xFC	; 252
  b8:	81 b9       	out	0x01, r24	; 1
}
  ba:	08 95       	ret

000000bc <eeWriteByte>:

uint8_t eeWriteByte(uint16_t address,uint8_t data)
{
  bc:	28 2f       	mov	r18, r24
    {
		/* (1<<TWINT) - reset to allow a new transmission
           (1<<TWSTA) - setup START
		   (1<<TWEN) - setup permission to work for TWI
		*/
		TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
  be:	54 ea       	ldi	r21, 0xA4	; 164
	   /* The constant part of the address 24LC64 - 1010 (see datasheet at 24XX64)
	      3 bits - variables (if suddenly we want to connect several identical chips
		  with the same factory addresses, they are useful, in another case, we set zeros)
		  then bit 0 - if you want to write to memory or 1 - if you read data from the memory of I2C EEPROM */
	   //TWDR = 0b1010‘000‘0
       TWDR = (slaveAddressConst<<4) + (slaveAddressVar<<1) + (WRITEFLAG);
  c0:	40 ea       	ldi	r20, 0xA0	; 160

	   // transfer the data contained in the data register TWDR
       TWCR=(1<<TWINT)|(1<<TWEN);
  c2:	34 e8       	ldi	r19, 0x84	; 132
    {
		/* (1<<TWINT) - reset to allow a new transmission
           (1<<TWSTA) - setup START
		   (1<<TWEN) - setup permission to work for TWI
		*/
		TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
  c4:	56 bf       	out	0x36, r21	; 54
        while(!(TWCR & (1<<TWINT)));	// waiting for approval
  c6:	06 b6       	in	r0, 0x36	; 54
  c8:	07 fe       	sbrs	r0, 7
  ca:	fd cf       	rjmp	.-6      	; 0xc6 <eeWriteByte+0xa>
		
	   // check I2C status
       if((TWSR & 0xF8) != TW_START)
  cc:	81 b1       	in	r24, 0x01	; 1
  ce:	88 7f       	andi	r24, 0xF8	; 248
  d0:	88 30       	cpi	r24, 0x08	; 8
  d2:	71 f5       	brne	.+92     	; 0x130 <eeWriteByte+0x74>
	   /* The constant part of the address 24LC64 - 1010 (see datasheet at 24XX64)
	      3 bits - variables (if suddenly we want to connect several identical chips
		  with the same factory addresses, they are useful, in another case, we set zeros)
		  then bit 0 - if you want to write to memory or 1 - if you read data from the memory of I2C EEPROM */
	   //TWDR = 0b1010‘000‘0
       TWDR = (slaveAddressConst<<4) + (slaveAddressVar<<1) + (WRITEFLAG);
  d4:	43 b9       	out	0x03, r20	; 3

	   // transfer the data contained in the data register TWDR
       TWCR=(1<<TWINT)|(1<<TWEN);
  d6:	36 bf       	out	0x36, r19	; 54

	   // waiting for the end of data transfer
       while(!(TWCR & (1<<TWINT)));
  d8:	06 b6       	in	r0, 0x36	; 54
  da:	07 fe       	sbrs	r0, 7
  dc:	fd cf       	rjmp	.-6      	; 0xd8 <eeWriteByte+0x1c>
    
    }while((TWSR & 0xF8) != TW_MT_SLA_ACK);
  de:	81 b1       	in	r24, 0x01	; 1
  e0:	88 7f       	andi	r24, 0xF8	; 248
  e2:	88 31       	cpi	r24, 0x18	; 24
  e4:	79 f7       	brne	.-34     	; 0xc4 <eeWriteByte+0x8>
        
    // write the most significant address bit in the data register
	// address 16 bit. so that first we transfer the highest digit, then the lower one
    TWDR=(address>>8);
  e6:	93 b9       	out	0x03, r25	; 3
	// send address
    TWCR=(1<<TWINT)|(1<<TWEN);
  e8:	84 e8       	ldi	r24, 0x84	; 132
  ea:	86 bf       	out	0x36, r24	; 54

	// wait for end of transmit
    while(!(TWCR & (1<<TWINT)));
  ec:	06 b6       	in	r0, 0x36	; 54
  ee:	07 fe       	sbrs	r0, 7
  f0:	fd cf       	rjmp	.-6      	; 0xec <eeWriteByte+0x30>

	// check I2C status
    if((TWSR & 0xF8) != TW_MT_DATA_ACK)
  f2:	81 b1       	in	r24, 0x01	; 1
  f4:	88 7f       	andi	r24, 0xF8	; 248
  f6:	88 32       	cpi	r24, 0x28	; 40
  f8:	d9 f4       	brne	.+54     	; 0x130 <eeWriteByte+0x74>
        return false;
	
	// send lower
    TWDR=(address);
  fa:	23 b9       	out	0x03, r18	; 3
    TWCR=(1<<TWINT)|(1<<TWEN);
  fc:	84 e8       	ldi	r24, 0x84	; 132
  fe:	86 bf       	out	0x36, r24	; 54
    while(!(TWCR & (1<<TWINT)));
 100:	06 b6       	in	r0, 0x36	; 54
 102:	07 fe       	sbrs	r0, 7
 104:	fd cf       	rjmp	.-6      	; 0x100 <eeWriteByte+0x44>

    if((TWSR & 0xF8) != TW_MT_DATA_ACK)
 106:	81 b1       	in	r24, 0x01	; 1
 108:	88 7f       	andi	r24, 0xF8	; 248
 10a:	88 32       	cpi	r24, 0x28	; 40
 10c:	89 f4       	brne	.+34     	; 0x130 <eeWriteByte+0x74>
        return false;

    // send data
    TWDR=(data);
 10e:	63 b9       	out	0x03, r22	; 3
    TWCR=(1<<TWINT)|(1<<TWEN);
 110:	84 e8       	ldi	r24, 0x84	; 132
 112:	86 bf       	out	0x36, r24	; 54
    while(!(TWCR & (1<<TWINT)));
 114:	06 b6       	in	r0, 0x36	; 54
 116:	07 fe       	sbrs	r0, 7
 118:	fd cf       	rjmp	.-6      	; 0x114 <eeWriteByte+0x58>

    if((TWSR & 0xF8) != TW_MT_DATA_ACK)
 11a:	81 b1       	in	r24, 0x01	; 1
 11c:	88 7f       	andi	r24, 0xF8	; 248
 11e:	88 32       	cpi	r24, 0x28	; 40
 120:	39 f4       	brne	.+14     	; 0x130 <eeWriteByte+0x74>
        return false;
	
    // send STOP packet
    TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWSTO);
 122:	84 e9       	ldi	r24, 0x94	; 148
 124:	86 bf       	out	0x36, r24	; 54
    
	// wait for accept STOP packet
    while(TWCR & (1<<TWSTO));
 126:	06 b6       	in	r0, 0x36	; 54
 128:	04 fc       	sbrc	r0, 4
 12a:	fd cf       	rjmp	.-6      	; 0x126 <eeWriteByte+0x6a>
 12c:	81 e0       	ldi	r24, 0x01	; 1
 12e:	08 95       	ret
 130:	80 e0       	ldi	r24, 0x00	; 0

    return true;
}
 132:	08 95       	ret

00000134 <eeReadByte>:

uint8_t eeReadByte(uint16_t address)
{
 134:	28 2f       	mov	r18, r24
    uint8_t data;
	// do similar tricks like in write function. establish conection with slave
    do
    {
        TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
 136:	54 ea       	ldi	r21, 0xA4	; 164
        while(!(TWCR & (1<<TWINT)));

        if((TWSR & 0xF8) != TW_START)
            return false;

        TWDR = (slaveAddressConst<<4) + (slaveAddressVar<<1) + WRITEFLAG;        
 138:	40 ea       	ldi	r20, 0xA0	; 160
        TWCR=(1<<TWINT)|(1<<TWEN);
 13a:	34 e8       	ldi	r19, 0x84	; 132
{
    uint8_t data;
	// do similar tricks like in write function. establish conection with slave
    do
    {
        TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
 13c:	56 bf       	out	0x36, r21	; 54
        while(!(TWCR & (1<<TWINT)));
 13e:	06 b6       	in	r0, 0x36	; 54
 140:	07 fe       	sbrs	r0, 7
 142:	fd cf       	rjmp	.-6      	; 0x13e <eeReadByte+0xa>

        if((TWSR & 0xF8) != TW_START)
 144:	81 b1       	in	r24, 0x01	; 1
 146:	88 7f       	andi	r24, 0xF8	; 248
 148:	88 30       	cpi	r24, 0x08	; 8
 14a:	09 f0       	breq	.+2      	; 0x14e <eeReadByte+0x1a>
 14c:	41 c0       	rjmp	.+130    	; 0x1d0 <eeReadByte+0x9c>
            return false;

        TWDR = (slaveAddressConst<<4) + (slaveAddressVar<<1) + WRITEFLAG;        
 14e:	43 b9       	out	0x03, r20	; 3
        TWCR=(1<<TWINT)|(1<<TWEN);
 150:	36 bf       	out	0x36, r19	; 54

        while(!(TWCR & (1<<TWINT)));
 152:	06 b6       	in	r0, 0x36	; 54
 154:	07 fe       	sbrs	r0, 7
 156:	fd cf       	rjmp	.-6      	; 0x152 <eeReadByte+0x1e>
    
    }while((TWSR & 0xF8) != TW_MT_SLA_ACK);
 158:	81 b1       	in	r24, 0x01	; 1
 15a:	88 7f       	andi	r24, 0xF8	; 248
 15c:	88 31       	cpi	r24, 0x18	; 24
 15e:	71 f7       	brne	.-36     	; 0x13c <eeReadByte+0x8>
        
	// send address
    TWDR=(address>>8);
 160:	93 b9       	out	0x03, r25	; 3
    TWCR=(1<<TWINT)|(1<<TWEN);
 162:	84 e8       	ldi	r24, 0x84	; 132
 164:	86 bf       	out	0x36, r24	; 54
    while(!(TWCR & (1<<TWINT)));
 166:	06 b6       	in	r0, 0x36	; 54
 168:	07 fe       	sbrs	r0, 7
 16a:	fd cf       	rjmp	.-6      	; 0x166 <eeReadByte+0x32>

    if((TWSR & 0xF8) != TW_MT_DATA_ACK)
 16c:	81 b1       	in	r24, 0x01	; 1
 16e:	88 7f       	andi	r24, 0xF8	; 248
 170:	88 32       	cpi	r24, 0x28	; 40
 172:	71 f5       	brne	.+92     	; 0x1d0 <eeReadByte+0x9c>
        return false;

    TWDR=(address);
 174:	23 b9       	out	0x03, r18	; 3
    TWCR=(1<<TWINT)|(1<<TWEN);
 176:	84 e8       	ldi	r24, 0x84	; 132
 178:	86 bf       	out	0x36, r24	; 54
    while(!(TWCR & (1<<TWINT)));
 17a:	06 b6       	in	r0, 0x36	; 54
 17c:	07 fe       	sbrs	r0, 7
 17e:	fd cf       	rjmp	.-6      	; 0x17a <eeReadByte+0x46>

    if((TWSR & 0xF8) != TW_MT_DATA_ACK)
 180:	81 b1       	in	r24, 0x01	; 1
 182:	88 7f       	andi	r24, 0xF8	; 248
 184:	88 32       	cpi	r24, 0x28	; 40
 186:	21 f5       	brne	.+72     	; 0x1d0 <eeReadByte+0x9c>
        return false;

	
    // send REPEAT START packet
    TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
 188:	84 ea       	ldi	r24, 0xA4	; 164
 18a:	86 bf       	out	0x36, r24	; 54
    while(!(TWCR & (1<<TWINT)));
 18c:	06 b6       	in	r0, 0x36	; 54
 18e:	07 fe       	sbrs	r0, 7
 190:	fd cf       	rjmp	.-6      	; 0x18c <eeReadByte+0x58>

    if((TWSR & 0xF8) != TW_REP_START)
 192:	81 b1       	in	r24, 0x01	; 1
 194:	88 7f       	andi	r24, 0xF8	; 248
 196:	80 31       	cpi	r24, 0x10	; 16
 198:	d9 f4       	brne	.+54     	; 0x1d0 <eeReadByte+0x9c>
        return false;

	// send address with read flag
    TWDR = (slaveAddressConst<<4) + (slaveAddressVar<<1) + READFLAG;        
 19a:	81 ea       	ldi	r24, 0xA1	; 161
 19c:	83 b9       	out	0x03, r24	; 3

    TWCR=(1<<TWINT)|(1<<TWEN);
 19e:	84 e8       	ldi	r24, 0x84	; 132
 1a0:	86 bf       	out	0x36, r24	; 54
    while(!(TWCR & (1<<TWINT)));
 1a2:	06 b6       	in	r0, 0x36	; 54
 1a4:	07 fe       	sbrs	r0, 7
 1a6:	fd cf       	rjmp	.-6      	; 0x1a2 <eeReadByte+0x6e>

    if((TWSR & 0xF8) != TW_MR_SLA_ACK)
 1a8:	81 b1       	in	r24, 0x01	; 1
 1aa:	88 7f       	andi	r24, 0xF8	; 248
 1ac:	80 34       	cpi	r24, 0x40	; 64
 1ae:	81 f4       	brne	.+32     	; 0x1d0 <eeReadByte+0x9c>
        return false;


    TWCR=(1<<TWINT)|(1<<TWEN);
 1b0:	84 e8       	ldi	r24, 0x84	; 132
 1b2:	86 bf       	out	0x36, r24	; 54

    while(!(TWCR & (1<<TWINT)));
 1b4:	06 b6       	in	r0, 0x36	; 54
 1b6:	07 fe       	sbrs	r0, 7
 1b8:	fd cf       	rjmp	.-6      	; 0x1b4 <eeReadByte+0x80>

	// check if data is valid
    if((TWSR & 0xF8) != TW_MR_DATA_NACK)
 1ba:	81 b1       	in	r24, 0x01	; 1
 1bc:	88 7f       	andi	r24, 0xF8	; 248
 1be:	88 35       	cpi	r24, 0x58	; 88
 1c0:	39 f4       	brne	.+14     	; 0x1d0 <eeReadByte+0x9c>
        return false;
	// get data from register
    data=TWDR;
 1c2:	93 b1       	in	r25, 0x03	; 3
	
	// send STOP packet
    TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWSTO);
 1c4:	84 e9       	ldi	r24, 0x94	; 148
 1c6:	86 bf       	out	0x36, r24	; 54
    
    while(TWCR & (1<<TWSTO));
 1c8:	06 b6       	in	r0, 0x36	; 54
 1ca:	04 fc       	sbrc	r0, 4
 1cc:	fd cf       	rjmp	.-6      	; 0x1c8 <eeReadByte+0x94>
 1ce:	01 c0       	rjmp	.+2      	; 0x1d2 <eeReadByte+0x9e>
 1d0:	90 e0       	ldi	r25, 0x00	; 0

    return data;
}
 1d2:	89 2f       	mov	r24, r25
 1d4:	08 95       	ret

000001d6 <_exit>:
 1d6:	f8 94       	cli

000001d8 <__stop_program>:
 1d8:	ff cf       	rjmp	.-2      	; 0x1d8 <__stop_program>
